-- Create RPC Function for Creator Access Control in Code Generation Portal
-- Execute this in your Supabase SQL Editor

CREATE OR REPLACE FUNCTION get_user_accessible_projects(p_user_id INTEGER)
RETURNS TABLE (
    project_id INTEGER,
    project_name TEXT,
    item_code TEXT,
    item_description TEXT,
    division_code TEXT,
    section_code TEXT,
    detailed_section_code TEXT,
    additional_level_name TEXT,
    additional_level_value TEXT,
    attributes JSONB,
    status TEXT,
    creator_category TEXT,
    project_classification TEXT,
    access_reason TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    user_category TEXT;
    user_role TEXT;
    project_record RECORD;
    has_individual_override BOOLEAN;
    override_type TEXT;
BEGIN
    -- Get user's category and role
    SELECT 
        COALESCE(cc.category_name, 'none') as category,
        u.role
    INTO user_category, user_role
    FROM users u
    LEFT JOIN user_creator_categories ucc ON u.id = ucc.user_id AND ucc.is_active = true
    LEFT JOIN creator_categories cc ON ucc.category_id = cc.id
    WHERE u.id = p_user_id;
    
    -- If user not found or not a creator, return empty result
    IF user_role IS NULL OR user_role != 'creator' THEN
        RETURN;
    END IF;
    
    -- If no category assigned, default to 'multiple' for backward compatibility
    IF user_category IS NULL OR user_category = 'none' THEN
        user_category := 'multiple';
    END IF;
    
    -- Loop through all approved projects
    FOR project_record IN
        SELECT 
            cp.id as proj_id,
            cp.project_name,
            cp.item_code,
            cp.item_description,
            cp.division_code,
            cp.section_code,
            cp.detailed_section_code,
            cp.additional_level_name,
            cp.additional_level_value,
            cp.attributes,
            cp.status,
            pc.classification_name as classification,
            SUBSTRING(cp.item_code, 1, 2) as division_from_code
        FROM classification_projects cp
        LEFT JOIN project_classifications pc ON cp.project_classification_id = pc.id
        WHERE cp.status = 'admin_approved'
    LOOP
        -- Check for individual project visibility override first
        SELECT 
            CASE 
                WHEN EXISTS (
                    SELECT 1 FROM user_project_visibility upv 
                    WHERE upv.user_id = p_user_id 
                    AND upv.project_id = project_record.proj_id 
                    AND upv.is_active = true
                ) THEN true
                ELSE false
            END,
            COALESCE(
                (SELECT upv.visibility_type 
                 FROM user_project_visibility upv 
                 WHERE upv.user_id = p_user_id 
                 AND upv.project_id = project_record.proj_id 
                 AND upv.is_active = true
                 LIMIT 1), 
                'default'
            )
        INTO has_individual_override, override_type;
        
        -- Apply individual override if exists
        IF has_individual_override THEN
            IF override_type = 'allow' THEN
                -- Always allow this project
                project_id := project_record.proj_id;
                project_name := project_record.project_name;
                item_code := project_record.item_code;
                item_description := project_record.item_description;
                division_code := project_record.division_code;
                section_code := project_record.section_code;
                detailed_section_code := project_record.detailed_section_code;
                additional_level_name := project_record.additional_level_name;
                additional_level_value := project_record.additional_level_value;
                attributes := project_record.attributes;
                status := project_record.status;
                creator_category := user_category;
                project_classification := project_record.classification;
                access_reason := 'Individual Override (Always Allow)';
                RETURN NEXT;
                CONTINUE;
            ELSIF override_type = 'hide' THEN
                -- Always hide this project
                CONTINUE;
            END IF;
            -- If override_type = 'default', fall through to category-based logic
        END IF;
        
        -- Apply category-based access rules
        CASE user_category
            WHEN 'multiple' THEN
                -- Multiple category users can access all projects
                project_id := project_record.proj_id;
                project_name := project_record.project_name;
                item_code := project_record.item_code;
                item_description := project_record.item_description;
                division_code := project_record.division_code;
                section_code := project_record.section_code;
                detailed_section_code := project_record.detailed_section_code;
                additional_level_name := project_record.additional_level_name;
                additional_level_value := project_record.additional_level_value;
                attributes := project_record.attributes;
                status := project_record.status;
                creator_category := user_category;
                project_classification := project_record.classification;
                access_reason := 'Category Rule (Multiple - Full Access)';
                RETURN NEXT;
                
            WHEN 'permanent' THEN
                -- Permanent users can access permanent and multiple projects
                IF project_record.classification IN ('permanent', 'multiple') THEN
                    project_id := project_record.proj_id;
                    project_name := project_record.project_name;
                    item_code := project_record.item_code;
                    item_description := project_record.item_description;
                    division_code := project_record.division_code;
                    section_code := project_record.section_code;
                    detailed_section_code := project_record.detailed_section_code;
                    additional_level_name := project_record.additional_level_name;
                    additional_level_value := project_record.additional_level_value;
                    attributes := project_record.attributes;
                    status := project_record.status;
                    creator_category := user_category;
                    project_classification := project_record.classification;
                    access_reason := CONCAT('Category Rule (Permanent - ', project_record.classification, ' Access)');
                    RETURN NEXT;
                END IF;
                
            WHEN 'non-permanent' THEN
                -- Non-permanent users can access non-permanent and multiple projects
                IF project_record.classification IN ('non-permanent', 'multiple') THEN
                    project_id := project_record.proj_id;
                    project_name := project_record.project_name;
                    item_code := project_record.item_code;
                    item_description := project_record.item_description;
                    division_code := project_record.division_code;
                    section_code := project_record.section_code;
                    detailed_section_code := project_record.detailed_section_code;
                    additional_level_name := project_record.additional_level_name;
                    additional_level_value := project_record.additional_level_value;
                    attributes := project_record.attributes;
                    status := project_record.status;
                    creator_category := user_category;
                    project_classification := project_record.classification;
                    access_reason := CONCAT('Category Rule (Non-Permanent - ', project_record.classification, ' Access)');
                    RETURN NEXT;
                END IF;
        END CASE;
    END LOOP;
    
    RETURN;
END;
$$;

-- Create user_project_visibility table if it doesn't exist
CREATE TABLE IF NOT EXISTS user_project_visibility (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    project_id INTEGER NOT NULL REFERENCES classification_projects(id) ON DELETE CASCADE,
    visibility_type TEXT NOT NULL CHECK (visibility_type IN ('allow', 'hide', 'default')),
    notes TEXT,
    is_active BOOLEAN DEFAULT true,
    created_by INTEGER REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_by INTEGER REFERENCES users(id),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(user_id, project_id)
);

-- Create RPC function to save user project visibility (for the Creator Category Management module)
CREATE OR REPLACE FUNCTION save_user_project_visibility(
    p_user_id INTEGER,
    p_visibility_settings JSONB,
    p_admin_user_id INTEGER
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    project_id_key TEXT;
    visibility_value TEXT;
    affected_count INTEGER := 0;
BEGIN
    -- Check if admin user has permission
    IF NOT EXISTS (
        SELECT 1 FROM users 
        WHERE id = p_admin_user_id 
        AND role = 'admin'
    ) THEN
        RETURN json_build_object(
            'success', false,
            'message', 'Access denied. Admin role required.'
        );
    END IF;
    
    -- Check if target user exists and is a creator
    IF NOT EXISTS (
        SELECT 1 FROM users 
        WHERE id = p_user_id 
        AND role = 'creator'
    ) THEN
        RETURN json_build_object(
            'success', false,
            'message', 'Target user not found or is not a creator.'
        );
    END IF;
    
    -- Loop through each project visibility setting
    FOR project_id_key IN SELECT jsonb_object_keys(p_visibility_settings)
    LOOP
        visibility_value := p_visibility_settings ->> project_id_key;
        
        -- Skip if visibility is 'default' - we'll delete these entries instead
        IF visibility_value = 'default' THEN
            -- Delete any existing override for this project
            DELETE FROM user_project_visibility 
            WHERE user_id = p_user_id 
            AND project_id = project_id_key::INTEGER;
        ELSE
            -- Insert or update the visibility setting
            INSERT INTO user_project_visibility (
                user_id, 
                project_id, 
                visibility_type, 
                created_by, 
                updated_by,
                notes
            ) VALUES (
                p_user_id,
                project_id_key::INTEGER,
                visibility_value,
                p_admin_user_id,
                p_admin_user_id,
                'Set via Creator Category Management'
            )
            ON CONFLICT (user_id, project_id) 
            DO UPDATE SET
                visibility_type = EXCLUDED.visibility_type,
                updated_by = EXCLUDED.updated_by,
                updated_at = NOW(),
                is_active = true;
        END IF;
        
        affected_count := affected_count + 1;
    END LOOP;
    
    RETURN json_build_object(
        'success', true,
        'message', 'User project visibility settings saved successfully',
        'affected_projects', affected_count
    );
END;
$$;

-- Create RPC function to get user project visibility (for the Creator Category Management module)
CREATE OR REPLACE FUNCTION get_user_project_visibility(
    p_user_id INTEGER,
    p_admin_user_id INTEGER
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    result JSON;
BEGIN
    -- Check if admin user has permission
    IF NOT EXISTS (
        SELECT 1 FROM users 
        WHERE id = p_admin_user_id 
        AND role = 'admin'
    ) THEN
        RETURN json_build_object(
            'success', false,
            'message', 'Access denied. Admin role required.'
        );
    END IF;
    
    -- Get user project visibility settings
    SELECT json_build_object(
        'success', true,
        'user_id', p_user_id,
        'visibility_settings', COALESCE(
            jsonb_object_agg(
                upv.project_id::TEXT, 
                upv.visibility_type
            ), 
            '{}'::jsonb
        )
    ) INTO result
    FROM user_project_visibility upv
    WHERE upv.user_id = p_user_id 
    AND upv.is_active = true;
    
    RETURN result;
END;
$$;

-- Grant permissions
GRANT EXECUTE ON FUNCTION get_user_accessible_projects(INTEGER) TO authenticated;
GRANT EXECUTE ON FUNCTION save_user_project_visibility(INTEGER, JSONB, INTEGER) TO authenticated;
GRANT EXECUTE ON FUNCTION get_user_project_visibility(INTEGER, INTEGER) TO authenticated;

-- Test the function
SELECT 'Testing project access control:' as info;
SELECT 'Function created successfully!' as status;
SELECT 'Code Generation Portal can now respect creator category rules!' as next_step;

-- Show example usage
SELECT 'Example: Get accessible projects for user ID 39' as example;
-- SELECT * FROM get_user_accessible_projects(39) LIMIT 5;
